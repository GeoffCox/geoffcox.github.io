import{s as q,a as _,k as P,m as I,e as c,p as d,b as u,q as g,t as $,i as p,w as L,f as m}from"../chunks/scheduler.75f5293f.js";import{S,i as z,c as h,b,m as x,t as v,a as C,d as k}from"../chunks/index.36074062.js";import{g as j,a as G}from"../chunks/spread.8a54911c.js";import{L as w}from"../chunks/Link.94f51915.js";import{P as N}from"../chunks/Post.19bcd7ab.js";function O(l){let e,s=`pretty-good-nlp is a deterministic, match-based, recognizer for natural language processing
		(NLP) scenarios.`,n,a,t=`I built it so that I could have a recogizer for my machine learning applications while waiting
		for data scientists to build a predictive model.`,o,i,y=`It has a some really nice features including phrase and pattern matching, negations, weighting,
		order evaluation, and noise removal.`;return{c(){e=c("p"),e.textContent=s,n=d(),a=c("p"),a.textContent=t,o=d(),i=c("p"),i.textContent=y},l(r){e=u(r,"P",{"data-svelte-h":!0}),g(e)!=="svelte-1xuqh1h"&&(e.textContent=s),n=$(r),a=u(r,"P",{"data-svelte-h":!0}),g(a)!=="svelte-kag0k4"&&(a.textContent=t),o=$(r),i=u(r,"P",{"data-svelte-h":!0}),g(i)!=="svelte-1e31anb"&&(i.textContent=y)},m(r,f){p(r,e,f),p(r,n,f),p(r,a,f),p(r,o,f),p(r,i,f)},p:L,d(r){r&&(m(e),m(n),m(a),m(o),m(i))}}}function U(l){let e,s,n,a;return e=new w({props:{href:"https://github.com/GeoffCox/pretty-good-nlp",kind:"github"}}),n=new w({props:{href:"https://geoffcox.github.io/demos/pretty-good-nlp/",kind:"demo"}}),{c(){h(e.$$.fragment),s=d(),h(n.$$.fragment)},l(t){b(e.$$.fragment,t),s=$(t),b(n.$$.fragment,t)},m(t,o){x(e,t,o),p(t,s,o),x(n,t,o),a=!0},p:L,i(t){a||(v(e.$$.fragment,t),v(n.$$.fragment,t),a=!0)},o(t){C(e.$$.fragment,t),C(n.$$.fragment,t),a=!1},d(t){t&&m(s),k(e,t),k(n,t)}}}function A(l){let e,s;const n=[{category:"Open Source Library"},{headline:"pretty-good-nlp"},{postUrl:"/pretty-good-nlp"},l[0]];let a={$$slots:{links:[U],default:[O]},$$scope:{ctx:l}};for(let t=0;t<n.length;t+=1)a=_(a,n[t]);return e=new N({props:a}),{c(){h(e.$$.fragment)},l(t){b(e.$$.fragment,t)},m(t,o){x(e,t,o),s=!0},p(t,[o]){const i=o&1?j(n,[n[0],n[1],n[2],G(t[0])]):{};o&2&&(i.$$scope={dirty:o,ctx:t}),e.$set(i)},i(t){s||(v(e.$$.fragment,t),s=!0)},o(t){C(e.$$.fragment,t),s=!1},d(t){k(e,t)}}}function B(l,e,s){const n=[];let a=P(e,n);return l.$$set=t=>{e=_(_({},e),I(t)),s(0,a=P(e,n))},[a]}class K extends S{constructor(e){super(),z(this,e,B,A,q,{})}}export{K as component};
