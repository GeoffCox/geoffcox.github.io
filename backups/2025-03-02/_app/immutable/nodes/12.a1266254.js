import{s as P,a as h,k as y,m as T,e as f,p as g,b as u,q as d,t as _,i as p,w as L,f as m}from"../chunks/scheduler.75f5293f.js";import{S,i as j,c as $,b,m as x,t as w,a as k,d as v}from"../chunks/index.36074062.js";import{g as q,a as H}from"../chunks/spread.8a54911c.js";import{L as I}from"../chunks/Link.879704e8.js";import{P as M}from"../chunks/Post.19bcd7ab.js";function z(l){let t,r=`When working on the Language Understanding Intelligence Service, we needed to efficiently find
		all the occurances of multiple strings in a large body of text. Matthew Hurst told me about Trie
		search and how the tree structure could match multiple search phrases at once. His team
		implemented the search on the server in C#.`,n,a,e=`Later, on my pretty-good-nlp project I needed to find multiple phrases in a string and looked for
		a good Trie search implementation in Typescript.  I found some partial JavaScript implementations
		but they had a few bugs and failed to find instances where one search phrase was a sub-phrase of another.`,o,i,C=`I wrote up my own implementation and decided that it was good enough to extract into its own package.
		Working on examples, I realized I could make the algorithm handle more than just words
		(i.e. tokenized text) and could leverage the <code>Iterator&lt;T&gt;</code>.`;return{c(){t=f("p"),t.textContent=r,n=g(),a=f("p"),a.textContent=e,o=g(),i=f("p"),i.innerHTML=C},l(s){t=u(s,"P",{"data-svelte-h":!0}),d(t)!=="svelte-1qshpqc"&&(t.textContent=r),n=_(s),a=u(s,"P",{"data-svelte-h":!0}),d(a)!=="svelte-rvtg6b"&&(a.textContent=e),o=_(s),i=u(s,"P",{"data-svelte-h":!0}),d(i)!=="svelte-1xojz33"&&(i.innerHTML=C)},m(s,c){p(s,t,c),p(s,n,c),p(s,a,c),p(s,o,c),p(s,i,c)},p:L,d(s){s&&(m(t),m(n),m(a),m(o),m(i))}}}function E(l){let t,r,n,a;return t=new I({props:{href:"https://github.com/GeoffCox/trie-search/blob/main/lib/README.md",kind:"github"}}),n=new I({props:{href:"https://geoffcox.github.io/demos/trie-search/",kind:"demo"}}),{c(){$(t.$$.fragment),r=g(),$(n.$$.fragment)},l(e){b(t.$$.fragment,e),r=_(e),b(n.$$.fragment,e)},m(e,o){x(t,e,o),p(e,r,o),x(n,e,o),a=!0},p:L,i(e){a||(w(t.$$.fragment,e),w(n.$$.fragment,e),a=!0)},o(e){k(t.$$.fragment,e),k(n.$$.fragment,e),a=!1},d(e){e&&m(r),v(t,e),v(n,e)}}}function U(l){let t,r;const n=[{category:"Open Source Library (2023-12-21)"},{headline:"trie-search"},{postUrl:"/trie-search"},l[0]];let a={$$slots:{links:[E],default:[z]},$$scope:{ctx:l}};for(let e=0;e<n.length;e+=1)a=h(a,n[e]);return t=new M({props:a}),{c(){$(t.$$.fragment)},l(e){b(t.$$.fragment,e)},m(e,o){x(t,e,o),r=!0},p(e,[o]){const i=o&1?q(n,[n[0],n[1],n[2],H(e[0])]):{};o&2&&(i.$$scope={dirty:o,ctx:e}),t.$set(i)},i(e){r||(w(t.$$.fragment,e),r=!0)},o(e){k(t.$$.fragment,e),r=!1},d(e){v(t,e)}}}function W(l,t,r){const n=[];let a=y(t,n);return l.$$set=e=>{t=h(h({},t),T(e)),r(0,a=y(t,n))},[a]}class R extends S{constructor(t){super(),j(this,t,W,U,P,{})}}export{R as component};
