import{s as I,a as h,k as L,m as P,e as f,p as g,b as u,q as d,t as _,i as m,w as T,f as p}from"../chunks/scheduler.75f5293f.js";import{S as H,i as M,c as $,b,m as w,t as k,a as x,d as v}from"../chunks/index.36074062.js";import{g as S,a as j}from"../chunks/spread.8a54911c.js";import{L as C}from"../chunks/Link.94f51915.js";import{P as z}from"../chunks/Post.19bcd7ab.js";function q(l){let t,r=`When working on the Language Understanding Intelligence Service, we needed to efficiently find
		all the occurances of multiple strings in a large body of text. <a href="https://www.linkedin.com/in/matthewfhurst/" target="_blank">Matthew Hurst</a> told me about Trie
		search and how the tree structure could match multiple search phrases at once. His team
		implemented the search on the server in C#.`,n,a,e=`Later, on my pretty-good-nlp project I needed to find multiple phrases in a string and looked for
		a good Trie search implementation in Typescript.  I found some partial JavaScript implementations
		but they had a few bugs and failed to find instances where one search phrase was a sub-phrase of another.`,s,i,y=`I wrote up my own implementation and decided that it was good enough to extract into its own package.
		Working on examples, I realized I could make the algorithm handle more than just words
		(i.e. tokenized text) and could leverage the <code>Iterator&lt;T&gt;</code>.`;return{c(){t=f("p"),t.innerHTML=r,n=g(),a=f("p"),a.textContent=e,s=g(),i=f("p"),i.innerHTML=y},l(o){t=u(o,"P",{"data-svelte-h":!0}),d(t)!=="svelte-1kn9m07"&&(t.innerHTML=r),n=_(o),a=u(o,"P",{"data-svelte-h":!0}),d(a)!=="svelte-rvtg6b"&&(a.textContent=e),s=_(o),i=u(o,"P",{"data-svelte-h":!0}),d(i)!=="svelte-1xojz33"&&(i.innerHTML=y)},m(o,c){m(o,t,c),m(o,n,c),m(o,a,c),m(o,s,c),m(o,i,c)},p:T,d(o){o&&(p(t),p(n),p(a),p(s),p(i))}}}function E(l){let t,r,n,a;return t=new C({props:{href:"https://github.com/GeoffCox/trie-search/blob/main/lib/README.md",kind:"github"}}),n=new C({props:{href:"https://geoffcox.github.io/demos/trie-search/",kind:"demo"}}),{c(){$(t.$$.fragment),r=g(),$(n.$$.fragment)},l(e){b(t.$$.fragment,e),r=_(e),b(n.$$.fragment,e)},m(e,s){w(t,e,s),m(e,r,s),w(n,e,s),a=!0},p:T,i(e){a||(k(t.$$.fragment,e),k(n.$$.fragment,e),a=!0)},o(e){x(t.$$.fragment,e),x(n.$$.fragment,e),a=!1},d(e){e&&p(r),v(t,e),v(n,e)}}}function U(l){let t,r;const n=[{category:"Open Source Library (2023-12-21)"},{headline:"trie-search"},{postUrl:"/trie-search"},l[0]];let a={$$slots:{links:[E],default:[q]},$$scope:{ctx:l}};for(let e=0;e<n.length;e+=1)a=h(a,n[e]);return t=new z({props:a}),{c(){$(t.$$.fragment)},l(e){b(t.$$.fragment,e)},m(e,s){w(t,e,s),r=!0},p(e,[s]){const i=s&1?S(n,[n[0],n[1],n[2],j(e[0])]):{};s&2&&(i.$$scope={dirty:s,ctx:e}),t.$set(i)},i(e){r||(k(t.$$.fragment,e),r=!0)},o(e){x(t.$$.fragment,e),r=!1},d(e){v(t,e)}}}function W(l,t,r){const n=[];let a=L(t,n);return l.$$set=e=>{t=h(h({},t),P(e)),r(0,a=L(t,n))},[a]}class R extends H{constructor(t){super(),M(this,t,W,U,I,{})}}export{R as component};
