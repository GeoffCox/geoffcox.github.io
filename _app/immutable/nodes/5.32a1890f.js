import{s as A,n as F}from"../chunks/scheduler.7a81b44c.js";import{S as G,i as M,e as f,s as _,m as w,c as h,d as k,F as I,h as g,n as q,g as b,o as m,j as R,k as a,p as z,t as L,a as P,q as S}from"../chunks/index.43019d97.js";import{L as T}from"../chunks/Link.b054f061.js";function B(j){let t,i,D="Library (open source)",$,o,E="binary-search",x,n,d,V=`I needed a binary search algorithm to find scroll offsets in a virtualized list. There didn't
			seem to be a package implementing a binary search in Typescript, so I created this one. It has
			a bonus feature. If the value isn't found, it provides the nearest range of indices where the
			value would have been.`,y,s,l,C,c,p;return l=new T({props:{href:"https://github.com/GeoffCox/binary-search/blob/main/lib/README.md",kind:"github"}}),c=new T({props:{href:"https://geoffcox.github.io/demos/binary-search/",kind:"demo"}}),{c(){t=f("div"),i=f("div"),i.textContent=D,$=_(),o=f("div"),o.textContent=E,x=_(),n=f("div"),d=f("p"),d.textContent=V,y=_(),s=f("div"),w(l.$$.fragment),C=_(),w(c.$$.fragment),this.h()},l(e){t=h(e,"DIV",{class:!0});var r=k(t);i=h(r,"DIV",{class:!0,"data-svelte-h":!0}),I(i)!=="svelte-6zf760"&&(i.textContent=D),$=g(r),o=h(r,"DIV",{class:!0,"data-svelte-h":!0}),I(o)!=="svelte-18qtpap"&&(o.textContent=E),x=g(r),n=h(r,"DIV",{class:!0});var u=k(n);d=h(u,"P",{"data-svelte-h":!0}),I(d)!=="svelte-1xizmyk"&&(d.textContent=V),y=g(u),s=h(u,"DIV",{class:!0});var v=k(s);q(l.$$.fragment,v),C=g(v),q(c.$$.fragment,v),v.forEach(b),u.forEach(b),r.forEach(b),this.h()},h(){m(i,"class","category svelte-1f14718"),m(o,"class","headline svelte-1f14718"),m(s,"class","links svelte-1f14718"),m(n,"class","details"),m(t,"class","root")},m(e,r){R(e,t,r),a(t,i),a(t,$),a(t,o),a(t,x),a(t,n),a(n,d),a(n,y),a(n,s),z(l,s,null),a(s,C),z(c,s,null),p=!0},p:F,i(e){p||(L(l.$$.fragment,e),L(c.$$.fragment,e),p=!0)},o(e){P(l.$$.fragment,e),P(c.$$.fragment,e),p=!1},d(e){e&&b(t),S(l),S(c)}}}class N extends G{constructor(t){super(),M(this,t,null,B,A,{})}}export{N as component};
